<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Class Dependencies</title>

  <style>

    * {
      padding: 0;
      margin: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
    }

    svg {
      position: absolute;
      top: 0;
    }

    text {
      font-family: 'Helvetica Neue', 'Helvetica', sans-serif;
      font-size: 8pt;
    }

    circle.leaf {
      stroke: black;
      stroke-width: 3px;
      fill: #FFFFFF;
    }

    .dashed {
      stroke-dasharray: 2, 2;
    }

    .node circle {
      fill: #fff;
      stroke: black;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

    .info-box {
      border: 2px solid #edeff0;
      position: fixed;
      top: 20px;
      right: 20px;
      width: 420px;
      height: 160px;

      padding: 10px;
    }

  </style>

</head>
<body>
<?xml version="1.0" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <defs>

    <marker id="markerArrow" markerWidth="10" markerHeight="10" viewBox="0 0 20 20" markerUnits="strokeWidth" refX="9"
            refY="3" orient="auto">
      <path d="M0,0 L0,6 L9,3 z" fill="#000000"/>
    </marker>

  </defs>
</svg>

<script src="js/redux/redux.min.js"></script>
<script src="js/underscore.js"></script>
<script src="js/d3/d3.js"></script>
<script src="js/d3-force/d3-force.js"></script>
<script src="js/class-graph.js"></script>

<script>

  // Bootstrap
  var classInheritanceEdges = roadRunnerDeps.classInheritanceEdges;
  var root = d3.stratify()
      .id(function (d) {
        return d.source;
      }).parentId(function (d) {
        return d.target;
      })
      (classInheritanceEdges);

  root.sort(function (a, b) {
    var nodeA = roadRunnerDeps.nodes[a.id].name.toLowerCase();
    var nodeB = roadRunnerDeps.nodes[b.id].name.toLowerCase();

    return nodeA.localeCompare(nodeB);
  });

  // Build node index, init start positions and visibility
  var nodeIndex = {};
  root.each(function (d) {
    d.visible = true;
    nodeIndex[d.id] = d;
  });
  var treeData;

  // Actions
  function initTree() {
    return {
      type: 'INIT_TREE'
    };
  }

  function toggleImplements(value) {
    return {
      type: 'TOGGLE_IMPLEMENTS',
      value: value
    };
  }

  function selectNode(nodeId, expanded) {
    return {
      type: 'SELECT_NODE',
      nodeId: nodeId,
      expanded: expanded
    }
  }

  // Reducers
  function showImplements(state, action) {

    if (action.type === 'TOGGLE_IMPLEMENTS') {
      return action.value;
    }

    if (state === undefined) {
      return false;
    }

    return state;
  }

  function selectedNode(state, action) {

    if (action.type === 'SELECT_NODE') {
      return {
        nodeId: action.nodeId,
        expanded: action.expanded
      };
    }

    if (state === undefined) {
      return {
        nodeId: null,
        expanded: false
      };
    }

    return state;
  }

  function nodePositions(state, action) {

    if (action.treeData) {
      var nodePositions = {};
      action.treeData.forEach(function (d) {
        nodePositions[d.id] = {
          visible: d.visible,
          x: d.x,
          y: d.y
        };
      });

      return Object.assign(JSON.parse(JSON.stringify(state)), nodePositions);
    }

    // Default state
    if (state === undefined) {
      var nodePositions = {};
      _.each(nodeIndex, function (node) {
        nodePositions[node.id] = {
          visible: true,
          x: 0,
          y: 0
        };
      });

      return nodePositions;
    }

    return state;
  }

  var reducer = Redux.combineReducers({
    showImplements,
    selectedNode,
    nodePositions
  });

  // Store
  var previousState = {};
  var store = Redux.createStore(
      reducer,
      Redux.applyMiddleware(
          // Previous state middleware
          function (store) {
            return function (next) {
              return function (action) {
                previousState = store.getState();
                next(action);
              }
            }
          },

          // Recompute tree middleware
          function (store) {
            return function (next) {
              return function (action) {

                var doRecompute = false;

                // Only recompute when expanding.
                // Optimizes performance cost of selecting nodes.
                if (action.type === 'SELECT_NODE') {

                  var newSource = nodeIndex[action.nodeId];
                  if (newSource && !isLeaf(newSource) && ((action.expanded && isCollapsed(newSource)) || (!action.expanded && isExpanded(newSource)))) {

                    doRecompute = true;

                    if (action.expanded) {
                      expand(newSource);
                    }
                    else {
                      collapse(newSource);
                    }
                  }
                }

                if (action.type === 'INIT_TREE') {
                  doRecompute = true;
                }

                if (((action.type === 'TOGGLE_IMPLEMENTS') && (action.value === true)) || store.getState().showImplements) {
                  var newSource = root;

                  if (action.type === 'SELECT_NODE') {
                    newSource = nodeIndex[action.nodeId];
                  } else if (store.getState().selectedNode.nodeId) {
                    newSource = nodeIndex[store.getState().selectedNode.nodeId];
                  }

                  var implementsEdges = findImplementsEdges(newSource);

                  _.each(implementsEdges, function(edge) {
                    var destination = nodeIndex[edge.edge.target];

                    if (destination) {
                      showTree(destination);
                      doRecompute = true;
                    }
                  });
                }

                if (doRecompute) {
                  console.log('RECOMPUTING NODE POSITIONS');

                  recomputeTree();

                  action.treeData = _.map(nodeIndex, function (node) {

                    if (node.visible) {
                      return {
                        id: node.id,
                        x: node.x,
                        y: node.y,
                        visible: node.visible
                      };
                    }

                    if (node.parent) {
                      return {
                        id: node.id,
                        x: node.parent.x,
                        y: node.parent.y,
                        visible: node.visible
                      };
                    }

                    return {
                      id: node.id,
                      x: 0,
                      y: 0,
                      visible: node.visible
                    };
                  });
                }

                next(action);
              }
            }
          },

          // Logging Middleware
          function (store) {
            return function (next) {
              return function (action) {
                console.log(action);
                next(action);
              }
            }
          }
      )
  );
  var previousState = store.getState();

  // Utils
  function observeStore(fn) {
    store.subscribe(function () {
      fn(previousState, store.getState());
    });
  }

  function observeStoreChanges(fn, key) {

    if (key) {
      observeStore(function (previousState, nextState) {
        if (previousState[key] !== nextState[key]) {
          fn(previousState, nextState);
        }
      });
    } else {
      observeStore(function (previousState, nextState) {
        if (previousState !== nextState) {
          fn(previousState, nextState);
        }
      });
    }
  }

  // Begin App
  var nodeRadius = 10;

  var implementsIndex = {};
  _.each(roadRunnerDeps.edges, function (edge, edgeKey) {

    if (edge.type === 'implements') {
      implementsIndex[edgeKey] = edge;
    }
  });

  function findImplementsEdges(sourceNode) {
    if (this.results && this.results[sourceNode.id]) {

      console.log('Returning memoized implements edges');

      return this.results[sourceNode.id];
    }


    var ancestorIds = [];
    sourceNode.ancestors().forEach(function (a) {
      if (a.id === sourceNode.id) {
        return;
      }
      ancestorIds.push(a.id);
    });

    var dependencyEdges = {};
    _.each(implementsIndex, function (edge) {

      var id = sourceNode.id + ':' + edge.id;

      if (dependencyEdges[id]) {
        return;
      }

      if (edge.source === sourceNode.id) {
        dependencyEdges[id] = {
          id: id,
          edge: edge,
          source: true,
          target: false,
          ancestor: false,
          actualSource: sourceNode
        };
      }

      if (ancestorIds.indexOf(edge.source) >= 0) {
        dependencyEdges[id] = {
          id: id,
          edge: edge,
          source: false,
          target: false,
          ancestor: true,
          actualSource: sourceNode
        };
      }
    });

    if (!this.results) {
      this.results = {};
    }

    this.results[sourceNode.id] = dependencyEdges;

    return dependencyEdges;
  }

  function previousNodePosition(node) {
    var previousNodePositions = previousState.nodePositions;

    var d = node;
    var previousPositions = previousNodePositions[d.id];

    // Implicit base-case is root node
    while ((previousPositions.x === undefined) || (previousPositions.y === undefined)) {
      if (d.parent) {
        d = d.parent;
      }

      previousPositions = previousNodePositions[d.id];
    }

    return {
      x: previousPositions.x,
      y: previousPositions.y
    }
  }

  function collapse(tData) {

    if (tData.children) {
      tData._children = tData.children;
      tData._children.forEach(function (c) {
        collapse(c);
        c.visible = false;
      });
      tData.children = null;
    }
  }

  function expand(tData) {
    if (tData._children) {
      tData.children = tData._children;
      tData._children = null;
      tData.children.forEach(function (c) {
        c.visible = true;
      });
    }
  }

  function isCollapsed(tData) {
    return tData._children? true : false;
  }

  function isExpanded(tData) {
    return tData.children? true : false;
  }

  function isLeaf(tData) {
    return !tData.children && !tData._children;
  }

  function showTree(node) {

    node.ancestors().forEach(function (d) {
      if (d.id === node.id) {
        return;
      }
      expand(d);
    });

  }

  var svg = d3.select('svg');

  var width = 20000;
  var height = 40000;
  svg.attr('width', width);
  svg.attr('height', height);
  var g = svg.append('g');

  //    var tree = d3.tree();
  var tree = d3.cluster();
  tree.separation(function (a, b) {
    return a.parent == b.parent ? 0.25 : 0.5;
  });
  tree.nodeSize([100, 100]);

  var i = 0,
      duration = 750;

  var nodeHeight = 30;
  var nodeWidth = 380;

  function exaggeratedDiagonal(s, d) {

    var x1 = s.x;
    var y1 = s.y;
    var x2 = d.x;
    var y2 = d.y;

    if (x1 === x2) {

      if (y1 === 0) {
        y1 += nodeRadius;
        y2 += nodeRadius;

        return `M ${y1} ${x1}
              C ${(y1) + (4 * nodeRadius)} ${x1 + (4 * nodeRadius)},
                ${(y1) + (4 * nodeRadius)} ${x2 - (4 * nodeRadius)},
                ${y2} ${x2}`;
      }
      else {
        y1 -= nodeRadius;
        y2 -= nodeRadius;

        return `M ${y1} ${x1}
              C ${(y1) + (4 * -nodeRadius)} ${x1 + (4 * nodeRadius)},
                ${(y1) + (4 * -nodeRadius)} ${x2 - (4 * nodeRadius)},
                ${y2} ${x2}`;
      }
    }
    else if ((y1 === 0) && (y2 === 0)) {
      y1 += nodeRadius;
      y2 += nodeRadius;

      return `M ${y1} ${x1}
            C ${(y1) + (nodeWidth / 2)} ${x1},
              ${(y1) + (nodeWidth / 2)} ${x2},
              ${y2} ${x2}`;

    }
    else if (y1 === y2) {
      y1 -= nodeRadius;
      y2 -= nodeRadius;

      return `M ${y1} ${x1}
            C ${(y1) - (nodeWidth / 2)} ${x1},
              ${(y1) - (nodeWidth / 2)} ${x2},
              ${y2} ${x2}`;
    }

    var path = `M ${y1} ${x1}
            C ${(y1) + (nodeWidth / 2)} ${x1},
              ${(y1) + (nodeWidth / 2)} ${x2},
              ${y2} ${x2}`;

    return path;

  }

  // Creates a curved (diagonal) path from parent to the child nodes
  function diagonal(s, d) {

    var y1 = s.y;
    var x1 = s.x;

    var y2 = d.y;
    var x2 = d.x;

    if (y1 > y2) {
      y1 -= nodeRadius;
      y2 += nodeRadius;
    } else {
      y1 += nodeRadius;
      y2 -= nodeRadius;
    }

    var path = `M ${y1} ${x1}
            C ${(y1 + y2) / 2} ${x1},
              ${(y1 + y2) / 2} ${x2},
              ${y2} ${x2}`;

    return path;
  }

  /**
   *
   * Resize the svg container according to the new layout
   *
   * @param treeData
   */
  function updateSvgDimensions(treeData) {
    var maxX = treeData.x;
    var minX = treeData.x;
    var maxY = treeData.y;
    var minY = treeData.y;

    var nodes = treeData.descendants();

    // Normalize for fixed-depth.
    nodes.forEach(function (d) {
      if (d.x > maxX) {
        maxX = d.x;
      }

      if (d.x < minX) {
        minX = d.x;
      }

      if (d.y > maxY) {
        maxY = d.y;
      }

      if (d.y < minY) {
        minY = d.y;
      }
    });

    var svgHeight = maxY - minY;
    var svgWidth = maxX - minX;

    svgWidth += 50; // padding
    svgHeight += 400; // padding

    g.transition()
        .duration(duration)
        .attr('transform', 'translate(' + 20 + ',' + (Math.abs(minX) + 25) + ')');


    var currentWidth = svg.attr('height');
    var currentHeight = svg.attr('width');

    if (svgWidth < currentWidth) {
      window.setTimeout(function () {
        svg.attr('height', svgWidth);
      }, duration);
    } else {
      svg.attr('height', svgWidth);
    }

    if (svgHeight < currentHeight) {
      window.setTimeout(function () {
        svg.attr('width', svgHeight);
      }, duration);
    } else {
      svg.attr('width', svgHeight);
    }
  }

  function drawNodes(treeData, source) {

    var previousNodePositions = previousState.nodePositions;

    // ignore the root node
    var nodes = treeData.descendants().slice(1);

    // Update the nodes...
    var node = g.selectAll('g.node')
        .data(nodes, function (d) {
          return d.id;
        });

    // Enter any new modes at the parent's previous position.
    var nodeEnter = node.enter()
        .append('g')
        .attr('class', 'node')
        .attr("transform", function (d) {
          var previousPositions = previousNodePosition(d);

          return "translate(" + previousPositions.y + "," + previousPositions.x + ")";
        })
        .on('click', function (d) {
          store.dispatch(selectNode(d.id, d._children ? true : true));
        });

    // Add Circle for the nodes
    nodeEnter.append('circle')
        .attr('class', 'node')
        .attr('r', 0)
    ;

    // Add labels for the nodes
    nodeEnter.append('text')
        .attr("dy", ".35em")
        .attr("x", 13)
        .attr("y", 0)
        .attr("text-anchor", "start")
        .text(function (d) {
          var parts = d.id.split(':');
          return (parts.length === 1) ? parts[0] : parts[1];
        })
    ;

    // UPDATE
    var nodeUpdate = nodeEnter.merge(node);

    // Transition to the proper position for the node
    nodeUpdate.transition()
        .duration(duration)
        .attr("transform", function (d) {
          return "translate(" + d.y + "," + d.x + ")";
        });

    // Update the node attributes and style
    nodeUpdate.select('circle.node')
        .attr('r', nodeRadius)
        .style('stroke', function (d) {
          var nodeData = roadRunnerDeps.nodes[d.id];

          if (nodeData && nodeData.extraData && nodeData.extraData.externalOrigin) {
            return "#67757B";
          }

          if (!nodeData || nodeData.type === 'class') {
            return "#4FC9FF";
          }

          if (nodeData.type === 'interface') {
            return "#a4d765";
          }

          if (nodeData.type === 'trait') {
            return "#ffc545";
          }
        })
        .style("fill", function (d) {
          var nodeData = roadRunnerDeps.nodes[d.id];

          if (!d._children) {
            return "#fff";
          }

          if (!nodeData || nodeData.type === 'class') {
            return "#9be0ff";
          }

          if (nodeData.type === 'interface') {
            return "#E4F7CB";
          }

          if (nodeData.type === 'trait') {
            return "#ffde96";
          }

        })
        .attr('cursor', 'pointer')
        .style('stroke-width', function (d) {
          if (d.id === source.id) {
            return '5px';
          }

          return '3px';
        });
    ;

    nodeUpdate.select('text')
        .style('font-weight', function (d) {
          if (d.id === source.id) {
            return 'bold';
          }

          return 'normal';
        });


    // Remove any exiting nodes
    var nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", function (d) {
          return "translate(" + source.y + "," + source.x + ")";
        })
        .remove();

    // On exit reduce the node circles size to 0
    nodeExit.select('circle')
        .attr('r', 1e-6);

    // On exit reduce the opacity of text labels
    nodeExit.select('text').style('fill-opacity', 1e-6);
  }

  function drawLinks(treeData, source) {
    var previousNodePositions = previousState.nodePositions;

    var links = treeData.descendants().slice(1);

    // Update the links...
    var link = g.selectAll('path.link')
        .data(links, function (d) {
          return d.id;
        });

    // Enter any new links at the parent's previous position.
    var linkEnter = link.enter().insert('path', "g")
        .attr("class", "link")
        .attr('d', function (d) {

          var lastVisibleParent = null;
          d.ancestors().forEach(function (a) {
            if (previousNodePositions[a.id].visible && !lastVisibleParent) {
              lastVisibleParent = a;
            }
          });

          if (!lastVisibleParent) {
            lastVisibleParent = root;
          }

          var lastVisibleParentPreviousPositions = previousNodePositions[lastVisibleParent.id];

          var o = {
            x: lastVisibleParentPreviousPositions.x,
            y: lastVisibleParentPreviousPositions.y
          };
          return diagonal(o, o)
        });

    // UPDATE
    var linkUpdate = linkEnter.merge(link);

    // Transition back to the parent element position
    linkUpdate
        .filter(function (d) {
          // don't draw edges to the namespace root
          return d.depth > 1;
        })
        .transition()
        .duration(duration)
        .attr('d', function (d) {
          return diagonal(d, d.parent)
        });

    // Remove any exiting links
    var linkExit = link.exit().transition()
        .duration(duration)
        .attr('d', function (d) {
          var o = {
            x: source.x,
            y: source.y
          };
          return diagonal(o, o)
        })
        .remove();
  }

  function recomputeTree() {
    treeData = tree(root);
    // Update y-position for nicely normalized depth
    treeData.descendants().forEach(function (d) {
      d.y = (d.depth - 1) * nodeWidth;
    });

    updateSvgDimensions(treeData);

    return treeData;
  }

  function updateGraph(previousState, nextState) {
    var sourceNode = nodeIndex[nextState.selectedNode.nodeId];

    if (!sourceNode) {
      sourceNode = root;
    }

    drawNodes(treeData, sourceNode);
    drawLinks(treeData, sourceNode);
  }
  observeStoreChanges(updateGraph);

  function updateLegend(previousState, nextState) {
    var sourceNode = roadRunnerDeps.nodes[nextState.selectedNode.nodeId];

    document.querySelectorAll('.legend--selected-node').forEach(function (domNode) {
      domNode.innerHTML = '';
    });

    if (sourceNode) {
      document.querySelectorAll('.legend--selected-node').forEach(function (domNode) {
        domNode.appendChild(document.createTextNode(' ' + sourceNode.name));
      });
    }

    if (nextState.showImplements) {
      var checkbox = document.querySelector('input[name="toggleImplements"]');
      if (checkbox) {
        checkbox.checked = 'checked';
      }
    } else {
      var checkbox = document.querySelector('input[name="toggleImplements"]');
      if (checkbox) {
        checkbox.checked = false;
      }
    }
  }
  observeStoreChanges(updateLegend);

  function drawImplementsEdges(previousState, nextState) {
    var sourceNode = nodeIndex[nextState.selectedNode.nodeId];

    if (!sourceNode) {
      return;
    }

    var paths = [];

    if (nextState.showImplements) {
      console.log('Drawing implements edges');

      paths = _.values(findImplementsEdges(sourceNode));
    }


    var selection = g.selectAll('path.coupling')
          .data(_.values(paths), function (d) {
            return d.id;
          });


    selection.enter()
          .insert('path', 'g')
          .attr('class', 'coupling')
          .attr('d', function (d) {
            var pos = previousNodePosition(sourceNode);
            return diagonal(pos, pos);
          })
          .attr('marker-end', 'url(#markerArrow)')
          .style('stroke-dasharray', function (d) {
            if (d.ancestor) {
              return ('3, 3, 5, 3');
            }

            if (d.target) {
              return ('3, 2');
            }

            return ('1, 0');
          })
          .attr('stroke', function (d) {
            if (d.edge.type === 'implements') {
              return '#a4d765';
            }

            return '#000';
          })
          .style('stroke-width', '2')
          .attr('fill', 'none')
          .transition()
          .duration(duration)
          .attr('d', function (d) {

            var dependencyNode = nodeIndex[d.edge.target];
            var localSource = sourceNode;

            if (d.target) {
              dependencyNode = localSource;
              localSource = nodeIndex[d.edge.source];
            }

            if (dependencyNode.depth === localSource.depth) {
              return exaggeratedDiagonal(localSource, dependencyNode);
            }

            return diagonal(localSource, dependencyNode);
          })
      ;

      console.log('Hiding implements edges');
      selection.exit()
          .transition()
          .duration(duration)
          .attr('d', function (d) {
            var localSource = d.actualSource;
            return diagonal(localSource, localSource)
          })
          .remove()
      ;
  }
  observeStoreChanges(drawImplementsEdges);


  // Init view
  root.children.forEach(function (d) {
    collapse(d);
  });
  store.dispatch(initTree());
</script>

<div class="info-box">
  Selected node:<span class="legend--selected-node"></span>
  <form id="graph-controls" name="legend" action="#" method="GET">
    <label><input type="checkbox" name="toggleImplements" value="true"/> Show implementation edges</label>
  </form>
</div>

<script>
  // Set up event handlers

  var form = document.getElementById('graph-controls');
  form.addEventListener('change', function () {
    var formData = new FormData(form);
    store.dispatch(toggleImplements(formData.get('toggleImplements') === 'true' ? true : false));
  });
</script>
</body>
</html>