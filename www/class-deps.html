<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Class Dependencies</title>

  <style>

    * {
      padding: 0;
      margin: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
    }

    svg {
      position: absolute;
      top: 0;
    }

    text {
      font-family: 'Helvetica Neue', 'Helvetica', sans-serif;
      font-size: 8pt;
    }

    circle.leaf {
      stroke: black;
      stroke-width: 3px;
      fill: #FFFFFF;
    }

    .dashed {
      stroke-dasharray: 2, 2;
    }


    .node circle {
      fill: #fff;
      stroke: black;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

  </style>

</head>
<body>
  <?xml version="1.0" standalone="no"?>
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>

  <script src="js/underscore.js"></script>
  <script src="js/d3/d3.js"></script>
  <script src="js/d3-force/d3-force.js"></script>
  <script src="js/class-graph.js"></script>

  <script>

    var classInheritanceEdges = roadRunnerDeps.classInheritanceEdges;

    var implementsIndex = {};
    _.each(roadRunnerDeps.edges, function(edge, edgeKey) {

      if ((edge.type === 'traitUse')
          || (edge.type === 'implements')
          || (edge.type === 'instantiates')
      ) {
        implementsIndex[edgeKey] = edge;
      }
    });


    var root = d3.stratify()
        .id(function(d) {
          return d.source;
        }).parentId(function(d) {
          return d.target;
        })
        (classInheritanceEdges);

    root.sort(function(a, b) {
      var nodeA = roadRunnerDeps.nodes[a.id].name.toLowerCase();
      var nodeB = roadRunnerDeps.nodes[b.id].name.toLowerCase();

      return nodeA.localeCompare(nodeB);
    });

    // Build node index, init start positions and visibility
    var nodeIndex = {};
    root.each(function(d) {
      nodeIndex[d.id] = d;
      d.visible = true;
      d.visible0 = true;
      d.x0 = 0;
      d.y0 = 0;
    });

    function collapse(tData) {

      if (tData.children) {
        tData._children = tData.children;
        tData._children.forEach(function(c) {
          collapse(c);
          c.visible = false;
        });
        tData.children = null;
      }
    }

    function expand(tData) {
      if (tData._children) {
        tData.children = tData._children;
        tData._children = null;
        tData.children.forEach(function(c) {
          c.visible = true;
        });
      }
    }

    function showTree(node) {

      node.ancestors().forEach(function(d) {
        if (d.id === node.id) {
          return;
        }
        expand(d);
      });

    }

    function click(tData) {

      if (tData._children) {
        expand(tData);
      } else if (tData.children) {
        collapse(tData);
      }

      _.each(implementsIndex, function(edge) {
        if (edge.source === tData.id) {
          showTree(nodeIndex[edge.target]);
        }

        if (edge.target === tData.id) {
          showTree(nodeIndex[edge.source]);
        }
      });


      update(tData);
    }

    root.children.forEach(function(d) {
      collapse(d);
    });


    var svg = d3.select('svg');
//    var width = window.innerWidth;
    var height = window.innerHeight;

    var width = 20000;
    var height = 40000;
    svg.attr('width', width);
    svg.attr('height', height);
    var g = svg.append('g');//.attr('transform', 'translate(20, 20)');

    //      var cluster = d3.cluster().size([height, width]);
//    var tree = d3.tree();
    var tree = d3.cluster();
    tree.separation(function(a, b) {
      return a.parent == b.parent ? 0.25 : 0.5;
    });
//    tree.size([height, width]);
    tree.nodeSize([100, 100]);


    var i = 0,
        duration = 750;

    var nodeHeight = 30;
    var nodeWidth = 380;

    function exaggeratedDiagonal(s, d) {

      var path = `M ${s.y} ${s.x}
            C ${(s.y) + (nodeWidth)} ${s.x},
              ${(s.y) + (nodeWidth)} ${d.x},
              ${d.y} ${d.x}`;

      return path;

    }

    // Creates a curved (diagonal) path from parent to the child nodes
    function diagonal(s, d) {

      var path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`;

      return path;
    }

    /**
     *
     * Resize the svg container according to the new layout
     *
     * @param treeData
     */
    function updateSvgDimensions(treeData) {
      var maxX = treeData.x;
      var minX = treeData.x;
      var maxY = treeData.y;
      var minY = treeData.y;

      var nodes = treeData.descendants();

      // Normalize for fixed-depth.
      nodes.forEach(function(d){
        if (d.x > maxX) {
          maxX = d.x;
        }

        if (d.x < minX) {
          minX = d.x;
        }

        if (d.y > maxY) {
          maxY = d.y;
        }

        if (d.y < minY) {
          minY = d.y;
        }
      });

      var svgHeight = maxY - minY;
      var svgWidth = maxX - minX;

      svgWidth += 50; // padding
      svgHeight += 400; // padding

      g.transition()
          .duration(duration)
          .attr('transform', 'translate(' + 20 + ',' + (Math.abs(minX) + 25) + ')');


      var currentWidth = svg.attr('height');
      var currentHeight = svg.attr('width');

      if (svgWidth < currentWidth) {
        window.setTimeout(function () {
          svg.attr('height', svgWidth);
        }, duration);
      } else {
        svg.attr('height', svgWidth);
      }

      if (svgHeight < currentHeight) {
        window.setTimeout(function () {
          svg.attr('width', svgHeight);
        }, duration);
      } else {
        svg.attr('width', svgHeight);
      }
    }

    function drawNodes(treeData, source) {

      // ignore the root node
      var nodes = treeData.descendants().slice(1);

      // Update the nodes...
      var node = g.selectAll('g.node')
          .data(nodes, function(d) {
            return d.id;
          });

      // Enter any new modes at the parent's previous position.
      var nodeEnter = node.enter()
          .append('g')
          .attr('class', 'node')
          .attr("transform", function(d) {

            var lastVisibleParent = null;
            d.ancestors().forEach(function(a) {
              if (a.visible0 && !lastVisibleParent) {
                lastVisibleParent = a;
              }
            });

            if (!lastVisibleParent) {
              lastVisibleParent = root;
            }

            return "translate(" + lastVisibleParent.y0 + "," + lastVisibleParent.x0 + ")";
          })
          .on('click', click);

      // Add Circle for the nodes
      nodeEnter.append('circle')
          .attr('class', 'node')
          .attr('r', 0)
      ;

      // Add labels for the nodes
      nodeEnter.append('text')
          .attr("dy", ".35em")
          .attr("x", 13)
          .attr("y", 0)
          .attr("text-anchor", "start")
          .text(function(d) {
            var parts = d.id.split(':');
            return (parts.length === 1)? parts[0] : parts[1];
          });

      // UPDATE
      var nodeUpdate = nodeEnter.merge(node);

      // Transition to the proper position for the node
      nodeUpdate.transition()
          .duration(duration)
          .attr("transform", function(d) {
            return "translate(" + d.y + "," + d.x + ")";
          });

      // Update the node attributes and style
      nodeUpdate.select('circle.node')
          .attr('r', 10)
          .style('stroke', function(d) {
            var nodeData = roadRunnerDeps.nodes[d.id];

            if (nodeData && nodeData.extraData && nodeData.extraData.externalOrigin) {
              return "#67757B";
            }

            if (!nodeData || nodeData.type === 'class') {
              return "#4FC9FF";
            }

            if (nodeData.type === 'interface') {
              return "#a4d765";
            }

            if (nodeData.type === 'trait') {
              return "#ffc545";
            }
          })
          .style("fill", function(d) {
            var nodeData = roadRunnerDeps.nodes[d.id];

            if (!d._children) {
              return "#fff";
            }

            if (!nodeData || nodeData.type === 'class') {
              return "#9be0ff";
            }

            if (nodeData.type === 'interface') {
              return "#E4F7CB";
            }

            if (nodeData.type === 'trait') {
              return "#ffde96";
            }

          })
          .attr('cursor', 'pointer');


      // Remove any exiting nodes
      var nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", function(d) {
            return "translate(" + source.y + "," + source.x + ")";
          })
          .remove();

      // On exit reduce the node circles size to 0
      nodeExit.select('circle')
          .attr('r', 1e-6);

      // On exit reduce the opacity of text labels
      nodeExit.select('text')
          .style('fill-opacity', 1e-6);
    }

    function drawLinks(treeData, source) {
      var links = treeData.descendants().slice(1);

      // Update the links...
      var link = g.selectAll('path.link')
          .data(links, function(d) {
            return d.id;
          });

      // Enter any new links at the parent's previous position.
      var linkEnter = link.enter().insert('path', "g")
          .attr("class", "link")
          .attr('d', function(d){

            var lastVisibleParent = null;
            d.ancestors().forEach(function(a) {
              if (a.visible0 && !lastVisibleParent) {
                lastVisibleParent = a;
              }
            });

            if (!lastVisibleParent) {
              lastVisibleParent = root;
            }

            var o = {
              x: lastVisibleParent.x0,
              y: lastVisibleParent.y0
            };
            return diagonal(o, o)
          });

      // UPDATE
      var linkUpdate = linkEnter.merge(link);

      // Transition back to the parent element position
      linkUpdate
          .filter(function (d) {
            // don't draw edges to the namespace root
            return d.depth > 1;
          })
          .transition()
          .duration(duration)
          .attr('d', function(d) {
            return diagonal(d, d.parent)
          });

      // Remove any exiting links
      var linkExit = link.exit().transition()
          .duration(duration)
          .attr('d', function(d) {
            var o = {
              x: source.x,
              y: source.y
            };
            return diagonal(o, o)
          })
          .remove();
    }

    function update(source) {

      g.selectAll('path.coupling').remove();
      
      // Assigns the x and y position for the nodes
      var treeData = tree(root);

      // Update y-position for nicely normalized depth
      treeData.descendants().forEach(function(d) {
        d.y = (d.depth - 1) * nodeWidth;
      });

      updateSvgDimensions(treeData);
      drawNodes(treeData, source);
      drawLinks(treeData, source);


      var ancestorIds = [];
      source.ancestors().forEach(function(a) {
        if (a.id === source.id) {
          return;
        }
        ancestorIds.push(a.id);
      });

      var dependencyEdges = {};
      _.each(implementsIndex, function(edge) {

        if (dependencyEdges[edge.id]) {
          return;
        }

        if (edge.source === source.id) {
          dependencyEdges[edge.id] = {
            edge: edge,
            source: true,
            target: false,
            ancestor: false
          };
        }

        if (edge.target === source.id) {
          dependencyEdges[edge.id] = {
            edge: edge,
            source: false,
            target: true,
            ancestor: false
          };
        }

        if (ancestorIds.indexOf(edge.source) >= 0) {
          dependencyEdges[edge.id] = {
            edge: edge,
            source: false,
            target: false,
            ancestor: true
          };
        }
      });

      g.selectAll('path.coupling')
          .data(_.values(dependencyEdges), function(d) {
            return d.id;
          })
          .enter()
          .insert('path', 'g')
          .attr('class', 'coupling')
          .attr('d', function(d) {
            return diagonal(source, source);
          })
          .style('stroke-dasharray', function(d) {
            if (d.ancestor) {
              return ('3, 3, 5, 3');
            }

            if (d.target) {
              return ('3, 1');
            }

            return ('1, 0');
          })
          .attr('stroke', function(d) {
            if (d.edge.type === 'implements') {
              return '#a4d765';
            }

            if (d.edge.type === 'traitUse') {
              return '#ffc545';
            }

            if (d.edge.type === 'instantiates') {
              return '#e05760';
            }

            return '#000';
          })
          .style('stroke-width', '2')
          .attr('fill', 'none')
          .transition()
          .duration(duration)
          .attr('d', function(d) {

            var dependencyNode;
            if (d.source) {
              dependencyNode = nodeIndex[d.edge.target];
            }
            else if (d.target) {
              dependencyNode = nodeIndex[d.edge.source];
            }
            else if (d.ancestor) {
              dependencyNode = nodeIndex[d.edge.target];
            }


            if (dependencyNode.depth === source.depth) {
              return exaggeratedDiagonal(source, dependencyNode);
            }

            return diagonal(source, dependencyNode);
          })
      ;


      // Store the old positions for transition.
      root.each(function(d){
        d.x0 = d.x;
        d.y0 = d.y;
      });

      _.each(nodeIndex, function(d) {
        d.visible0 = d.visible;
      });

    }



    update(root);
  </script>

</body>
</html>