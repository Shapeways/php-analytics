<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Class Dependencies</title>

  <style>

    * {
      padding: 0;
      margin: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
    }

    svg {
      position: absolute;
      top: 0;
    }

    text {
      font-family: 'Helvetica Neue', 'Helvetica', sans-serif;
      font-size: 8pt;
    }

    circle.leaf {
      stroke: black;
      stroke-width: 3px;
      fill: #FFFFFF;
    }

    .dashed {
      stroke-dasharray: 2, 2;
    }


    .node circle {
      fill: #fff;
      stroke: black;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

  </style>

</head>
<body>
  <?xml version="1.0" standalone="no"?>
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>

  <script src="js/underscore.js"></script>
  <script src="js/d3/d3.js"></script>
  <script src="js/d3-force/d3-force.js"></script>
  <script src="js/class-graph.js"></script>

  <script>

    var classInheritanceEdges = roadRunnerDeps.classInheritanceEdges;

    var root = d3.stratify()
        .id(function(d) {
          return d.source;
        }).parentId(function(d) {
          return d.target;
        })
        (classInheritanceEdges);

    root.sort(function(a, b) {
      var nodeA = roadRunnerDeps.nodes[a.id].name.toLowerCase();
      var nodeB = roadRunnerDeps.nodes[b.id].name.toLowerCase();

      return nodeA.localeCompare(nodeB);
    });

    function collapse(tData) {

      if (tData.children) {
        tData._children = tData.children;
        tData._children.forEach(collapse);
        tData.children = null;
      }
    }

    function expand(tData) {
      if (tData._children) {
        tData.children = tData._children;
        tData._children = null;
      }
    }

    function click(tData) {
      if (tData._children) {
        expand(tData);
      } else if (tData.children) {
        collapse(tData);
      }

      update(tData);
    }

    root.children.forEach(collapse);


    var svg = d3.select('svg');
//    var width = window.innerWidth;
    var height = window.innerHeight;

    var width = 20000;
    var height = 40000;
    svg.attr('width', width);
    svg.attr('height', height);
    var g = svg.append('g');//.attr('transform', 'translate(20, 20)');

    //      var cluster = d3.cluster().size([height, width]);
//    var tree = d3.tree();
    var tree = d3.cluster();
    tree.separation(function(a, b) {
      return a.parent == b.parent ? 0.25 : 0.5;
    });
//    tree.size([height, width]);
    tree.nodeSize([100, 100]);


    var i = 0,
        duration = 750;

    var nodeHeight = 30;
    var nodeWidth = 380;

    root.x0 = 0;
    root.y0 = 0;

    // Creates a curved (diagonal) path from parent to the child nodes
    function diagonal(s, d) {

      var path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`;

      return path;
    }

    /**
     *
     * Resize the svg container according to the new layout
     *
     * @param treeData
     */
    function updateSvgDimensions(treeData) {
      var maxX = treeData.x;
      var minX = treeData.x;
      var maxY = treeData.y;
      var minY = treeData.y;

      var nodes = treeData.descendants();

      // Normalize for fixed-depth.
      nodes.forEach(function(d){
        if (d.x > maxX) {
          maxX = d.x;
        }

        if (d.x < minX) {
          minX = d.x;
        }

        if (d.y > maxY) {
          maxY = d.y;
        }

        if (d.y < minY) {
          minY = d.y;
        }
      });

      var svgHeight = maxY - minY;
      var svgWidth = maxX - minX;

      svgWidth += 50; // padding
      svgHeight += 400; // padding

      g.transition()
          .duration(duration)
          .attr('transform', 'translate(' + 20 + ',' + (Math.abs(minX) + 25) + ')');


      var currentWidth = svg.attr('height');
      var currentHeight = svg.attr('width');

      if (svgWidth < currentWidth) {
        window.setTimeout(function () {
          svg.attr('height', svgWidth);
        }, duration);
      } else {
        svg.attr('height', svgWidth);
      }

      if (svgHeight < currentHeight) {
        window.setTimeout(function () {
          svg.attr('width', svgHeight);
        }, duration);
      } else {
        svg.attr('width', svgHeight);
      }
    }

    function drawNodes(treeData, source) {

      // ignore the root node
      var nodes = treeData.descendants().slice(1);

      // Update the nodes...
      var node = g.selectAll('g.node')
          .data(nodes, function(d) {

            return d.id;
          });

      // Enter any new modes at the parent's previous position.
      var nodeEnter = node.enter()
          .append('g')
          .attr('class', 'node')
          .attr("transform", function(d) {
            return "translate(" + source.y0 + "," + source.x0 + ")";
          })
          .on('click', click);

      // Add Circle for the nodes
      nodeEnter.append('circle')
          .attr('class', 'node')
          .attr('r', 0)
      ;

      // Add labels for the nodes
      nodeEnter.append('text')
          .attr("dy", ".35em")
          .attr("x", 13)
          .attr("y", 0)
          .attr("text-anchor", "start")
          .text(function(d) {
            var parts = d.id.split(':');
            return (parts.length === 1)? parts[0] : parts[1];
          });

      // UPDATE
      var nodeUpdate = nodeEnter.merge(node);

      // Transition to the proper position for the node
      nodeUpdate.transition()
          .duration(duration)
          .attr("transform", function(d) {
            return "translate(" + d.y + "," + d.x + ")";
          });

      // Update the node attributes and style
      nodeUpdate.select('circle.node')
          .attr('r', 10)
          .style('stroke', function(d) {
            var nodeData = roadRunnerDeps.nodes[d.id];

            if (nodeData && nodeData.extraData && nodeData.extraData.externalOrigin) {
              return "#67757B";
            }

            if (!nodeData || nodeData.type === 'class') {
              return "#4FC9FF";
            }

            if (nodeData.type === 'interface') {
              return "#a4d765";
            }

            if (nodeData.type === 'trait') {
              return "#ffc545";
            }
          })
          .style("fill", function(d) {
            var nodeData = roadRunnerDeps.nodes[d.id];

            if (!d._children) {
              return "#fff";
            }

            if (!nodeData || nodeData.type === 'class') {
              return "#9be0ff";
            }

            if (nodeData.type === 'interface') {
              return "#E4F7CB";
            }

            if (nodeData.type === 'trait') {
              return "#ffde96";
            }

          })
          .attr('cursor', 'pointer');


      // Remove any exiting nodes
      var nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", function(d) {
            return "translate(" + source.y + "," + source.x + ")";
          })
          .remove();

      // On exit reduce the node circles size to 0
      nodeExit.select('circle')
          .attr('r', 1e-6);

      // On exit reduce the opacity of text labels
      nodeExit.select('text')
          .style('fill-opacity', 1e-6);
    }

    function drawLinks(treeData, source) {
      var links = treeData.descendants().slice(1);

      // Update the links...
      var link = g.selectAll('path.link')
          .data(links, function(d) {
            return d.id;
          });

      // Enter any new links at the parent's previous position.
      var linkEnter = link.enter().insert('path', "g")
          .attr("class", "link")
          .attr('d', function(d){
            var o = {
              x: source.x0,
              y: source.y0}
            return diagonal(o, o)
          });

      // UPDATE
      var linkUpdate = linkEnter.merge(link);

      // Transition back to the parent element position
      linkUpdate
          .filter(function (d) {
            // don't draw edges to the namespace root
            return d.depth > 1;
          })
          .transition()
          .duration(duration)
          .attr('d', function(d) {
            return diagonal(d, d.parent)
          });

      // Remove any exiting links
      var linkExit = link.exit().transition()
          .duration(duration)
          .attr('d', function(d) {
            var o = {
              x: source.x,
              y: source.y
            };
            return diagonal(o, o)
          })
          .remove();
    }

    function update(source) {
      
      // Assigns the x and y position for the nodes
      var treeData = tree(root);

      // Update y-position for nicely normalized depth
      treeData.descendants().forEach(function(d) {
        d.y = (d.depth - 1) * nodeWidth;
      });

      updateSvgDimensions(treeData);
      drawNodes(treeData, source);
      drawLinks(treeData, source);

      // Store the old positions for transition.
      treeData.descendants().forEach(function(d){
        d.x0 = d.x;
        d.y0 = d.y;
      });

    }



    update(root);
  </script>

</body>
</html>