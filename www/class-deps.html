<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Class Dependencies</title>

  <style>

    * {
      padding: 0;
      margin: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
    }

    svg {
      position: absolute;
      top: 0;
    }

    text {
      font-family: 'Helvetica Neue', 'Helvetica', sans-serif;
      font-size: 8pt;
    }

    circle.leaf {
      stroke: black;
      stroke-width: 3px;
      fill: #FFFFFF;
    }

    .dashed {
      stroke-dasharray: 2, 2;
    }

    .node circle {
      fill: #fff;
      stroke: black;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .node--selected-text {
      font-weight: bold;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

    .info-box {
      border: 2px solid #edeff0;
      position: fixed;
      top: 20px;
      right: 20px;
      width: 420px;
      height: 160px;

      padding: 10px;
    }

    .dependency {
    }

    .dependency--ancestor {
      stroke-dasharray: 3, 3, 5, 3;
    }

    .implements {
      stroke: #a4d765;
      fill: none;
      stroke-width: 2;
      marker-end: url(#markerArrow);
    }

  </style>

</head>
<body>
<?xml version="1.0" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <defs>

    <marker id="markerArrow" markerWidth="10" markerHeight="10" viewBox="0 0 20 20" markerUnits="strokeWidth" refX="9"
            refY="3" orient="auto">
      <path d="M0,0 L0,6 L9,3 z" fill="#000000"/>
    </marker>

  </defs>
</svg>

<script src="js/redux/redux.min.js"></script>
<script src="js/underscore.js"></script>
<script src="js/d3/d3.js"></script>
<script src="js/d3-force/d3-force.js"></script>

<script>

  // Bootstrap
  var root;

  // Build node index, init start positions and visibility
  var nodeIndex;
  var treeData;
  var roadRunnerNodes;
  var implementsIndex;

  // Actions
  function initTree(classInheritanceEdges, nodes, edges) {
    root = d3.stratify()
        .id(function (d) {
          return d.source;
        }).parentId(function (d) {
          return d.target;
        })
        (classInheritanceEdges);

    root.sort(function (a, b) {
      var nodeA = nodes[a.id].name.toLowerCase();
      var nodeB = nodes[b.id].name.toLowerCase();

      return nodeA.localeCompare(nodeB);
    });

    nodeIndex = {};
    root.each(function (d) {
      nodeIndex[d.id] = d;
    });

    roadRunnerNodes = nodes;

    implementsIndex = {};
    _.each(edges, function (edge, edgeKey) {

      if (edge.type === 'implements') {
        implementsIndex[edgeKey] = edge;
      }
    });

    return {
      type: 'INIT_TREE'
    };
  }

  function toggleImplements(toggleImplements, toggleImplementsImplicit, toggleImplementsTarget) {

    var showImplements = {
      dependencyType: 'implements',
      showSource: toggleImplements,
      showImplicit: toggleImplementsImplicit,
      showTargets: toggleImplementsTarget
    };

    return {
      type: 'TOGGLE_IMPLEMENTS',
      showImplements: showImplements
    };
  }

  function selectNode(nodeId, expanded) {
    return {
      type: 'SELECT_NODE',
      nodeId: nodeId,
      expanded: expanded
    }
  }

  // Reducers
  function showImplements(state, action) {

    if (action.type === 'TOGGLE_IMPLEMENTS') {
      return action.showImplements;
    }

    if (state === undefined) {
      return {
        dependencyType: 'implements',
        showSource: false,
        showImplicit: false,
        showTargets: false
      };
    }

    return state;
  }

  function selectedNode(state, action) {

    if (action.type === 'SELECT_NODE') {
      return {
        nodeId: action.nodeId,
        expanded: action.expanded
      };
    }

    if (state === undefined) {
      return {
        nodeId: null,
        expanded: false
      };
    }

    return state;
  }

  function nodePositions(state, action) {

    if (nodeIndex) {
      var nodePositions = {};
      _.each(nodeIndex, function (d) {
        nodePositions[d.id] = {
          x: d.x,
          y: d.y
        };
      });

      return Object.assign(JSON.parse(JSON.stringify(state)), nodePositions);
    }

    // Default state
    if (state === undefined) {
      var nodePositions = {};
      _.each(nodeIndex, function (node) {
        nodePositions[node.id] = {
          x: 0,
          y: 0
        };
      });

      return nodePositions;
    }

    return state;
  }

  var reducer = Redux.combineReducers({
    showImplements,
    selectedNode,
    nodePositions
  });

  // Store
  var previousState = {};
  var store = Redux.createStore(
      reducer,
      Redux.applyMiddleware(
          // Perf timing middleware
          function (store) {
            return function(next) {
              return function (action) {
                var startDispatch = window.performance.now();

                next(action);

                var endDispatch = window.performance.now();

                console.log(action.type + ' â€“ ' + (endDispatch - startDispatch).toFixed(2) + 'ms', action);

              }
            }
          },

          // Previous state middleware
          function (store) {
            return function (next) {
              return function (action) {
                previousState = store.getState();
                next(action);
              }
            }
          },

          // Recompute tree middleware
          function (store) {
            return function (next) {
              return function (action) {

                var doRecompute = false;

                if (action.type === 'INIT_TREE') {
                  root.children.forEach(function (d) {
                    collapse(d);
                  });
                  doRecompute = true;
                }


                var newSource;
                if (action.type === 'SELECT_NODE') {
                  newSource = nodeIndex[action.nodeId];
                } else if (store.getState().selectedNode.nodeId) {
                  newSource = nodeIndex[store.getState().selectedNode.nodeId];
                }

                // Only recompute when expanding.
                // Optimizes performance cost of selecting nodes.
                if (action.type === 'SELECT_NODE') {
                  if (action.expanded) {
                    expand(newSource);
                  }
                  else {
                    collapse(newSource);
                  }
                }


                var showImplementsValue = store.getState().showImplements;
                if (action.type === 'TOGGLE_IMPLEMENTS') {
                  showImplementsValue = action.showImplements;
                }

                if (showImplementsValue.showSource || showImplementsValue.showImplicit || showImplementsValue.showTargets) {

                  var implementsEdges = findImplementsEdges(newSource, showImplementsValue.showSource, showImplementsValue.showImplicit, showImplementsValue.showTargets);

                  _.each(implementsEdges, function(edge) {
                    var destination;
                    if (edge.target) {
                      destination = nodeIndex[edge.edge.source];
                    }
                    else {
                      destination = nodeIndex[edge.edge.target];
                    }

                    if (destination) {
                      showTree(destination);
                    }
                  });
                }


                console.log('RECOMPUTING NODE POSITIONS');
                recomputeTree();

                action.treeData = _.map(nodeIndex, function (node) {

                  if (node.x && node.y) {
                    return {
                      id: node.id,
                      x: node.x,
                      y: node.y
                    };
                  }

                  if (node.parent) {
                    return {
                      id: node.id,
                      x: node.parent.x,
                      y: node.parent.y
                    };
                  }

                  return {
                    id: node.id,
                    x: 0,
                    y: 0
                  };
                });


                next(action);
              }
            }
          }
      )
  );
  var previousState = store.getState();

  // Utils
  function observeStore(fn) {
    store.subscribe(function () {
      fn(previousState, store.getState());
    });
  }

  function observeStoreChanges(fn, key) {

    if (key) {
      observeStore(function (previousState, nextState) {
        if (previousState[key] !== nextState[key]) {
          fn(previousState, nextState);
        }
      });
    } else {
      observeStore(function (previousState, nextState) {
        if (previousState !== nextState) {
          fn(previousState, nextState);
        }
      });
    }
  }

  // Begin App
  var nodeRadius = 10;

  function findImplementsEdges(sourceNode, includeSourceDeps, includeAncestors, includeTarget) {
    var dependencyEdges = {};

    if (!sourceNode) {
      return dependencyEdges;
    }

    var ancestorIds = [];
    sourceNode.ancestors().forEach(function (a) {
      if (a.id === sourceNode.id) {
        return;
      }
      ancestorIds.push(a.id);
    });


    _.each(implementsIndex, function (edge) {

      var id = sourceNode.id + ':' + edge.id;

      if (dependencyEdges[id]) {
        return;
      }

      if (includeSourceDeps && (edge.source === sourceNode.id)) {
        dependencyEdges[id] = {
          id: id,
          edge: edge,
          source: true,
          target: false,
          ancestor: false,
          actualSource: sourceNode,
          actualTarget: nodeIndex[edge.target]
        };
      }
      else if (includeAncestors && ancestorIds.indexOf(edge.source) >= 0) {
        dependencyEdges[id] = {
          id: id,
          edge: edge,
          source: false,
          target: false,
          ancestor: true,
          actualSource: sourceNode,
          actualTarget: nodeIndex[edge.target]
        };
      }
      else if (includeTarget && (edge.target === sourceNode.id)) {
        dependencyEdges[id] = {
          id: id,
          edge: edge,
          source: false,
          target: true,
          ancestor: false,
          actualSource: nodeIndex[edge.target],
          actualTarget: nodeIndex[edge.source]
        };
      }
    });

    return dependencyEdges;
  }

  function previousNodePosition(node) {
    var previousNodePositions = previousState.nodePositions;

    var d = node;
    var previousPositions = previousNodePositions[d.id];

    // base case
    if (previousPositions === undefined) {
      return {
        x: 0,
        y: 0
      };
    }

    // Implicit base-case is root node
    while ((previousPositions.x === undefined) || (previousPositions.y === undefined)) {
      if (d.parent) {
        d = d.parent;
      }

      previousPositions = previousNodePositions[d.id];
    }

    return {
      x: previousPositions.x,
      y: previousPositions.y
    }
  }


  // D3 helpers
  function collapse(tData) {

    if (tData.children) {
      tData._children = tData.children;
      tData._children.forEach(function (c) {
        collapse(c);
      });
      tData.children = null;
    }
  }

  function expand(tData) {
    if (tData._children) {
      tData.children = tData._children;
      tData._children = null;
    }
  }

  function isCollapsed(tData) {
    return tData._children? true : false;
  }

  function isExpanded(tData) {
    return tData.children? true : false;
  }

  function isLeaf(tData) {
    return !tData.children && !tData._children;
  }

  function showTree(node) {

    node.ancestors().forEach(function (d) {
      if (d.id === node.id) {
        return;
      }
      expand(d);
    });

  }

  function startTransition(selection) {
    return selection
        .transition()
        .delay(function(d, i) {
          return i * 250;
        })
        .duration(750)
        ;
  }

  var svg = d3.select('svg');

  var width = 20000;
  var height = 40000;
  svg.attr('width', width);
  svg.attr('height', height);
  var g = svg.append('g');

  //    var tree = d3.tree();
  var tree = d3.cluster();
  tree.separation(function (a, b) {
    return a.parent == b.parent ? 0.25 : 0.5;
  });
  tree.nodeSize([100, 100]);

  var i = 0,
      duration = 750;

  var nodeHeight = 30;
  var nodeWidth = 380;

  function exaggeratedDiagonal(s, d) {

    var x1 = s.x;
    var y1 = s.y;
    var x2 = d.x;
    var y2 = d.y;

    if (x1 === x2) {

      if (y1 === 0) {
        y1 += nodeRadius;
        y2 += nodeRadius;

        return `M ${y1} ${x1}
              C ${(y1) + (4 * nodeRadius)} ${x1 + (4 * nodeRadius)},
                ${(y1) + (4 * nodeRadius)} ${x2 - (4 * nodeRadius)},
                ${y2} ${x2}`;
      }
      else {
        y1 -= nodeRadius;
        y2 -= nodeRadius;

        return `M ${y1} ${x1}
              C ${(y1) + (4 * -nodeRadius)} ${x1 + (4 * nodeRadius)},
                ${(y1) + (4 * -nodeRadius)} ${x2 - (4 * nodeRadius)},
                ${y2} ${x2}`;
      }
    }
    else if ((y1 === 0) && (y2 === 0)) {
      y1 += nodeRadius;
      y2 += nodeRadius;

      return `M ${y1} ${x1}
            C ${(y1) + (nodeWidth / 2)} ${x1},
              ${(y1) + (nodeWidth / 2)} ${x2},
              ${y2} ${x2}`;

    }
    else if (y1 === y2) {
      y1 -= nodeRadius;
      y2 -= nodeRadius;

      return `M ${y1} ${x1}
            C ${(y1) - (nodeWidth / 2)} ${x1},
              ${(y1) - (nodeWidth / 2)} ${x2},
              ${y2} ${x2}`;
    }

    var path = `M ${y1} ${x1}
            C ${(y1) + (nodeWidth / 2)} ${x1},
              ${(y1) + (nodeWidth / 2)} ${x2},
              ${y2} ${x2}`;

    return path;

  }

  // Creates a curved (diagonal) path from parent to the child nodes
  function diagonal(s, d) {

    var y1 = s.y;
    var x1 = s.x;

    var y2 = d.y;
    var x2 = d.x;

    if (y1 > y2) {
      y1 -= nodeRadius;
      y2 += nodeRadius;
    } else {
      y1 += nodeRadius;
      y2 -= nodeRadius;
    }

    var path = `M ${y1} ${x1}
            C ${(y1 + y2) / 2} ${x1},
              ${(y1 + y2) / 2} ${x2},
              ${y2} ${x2}`;

    return path;
  }

  /**
   *
   * Resize the svg container according to the new layout
   *
   * @param treeData
   */
  function updateSvgDimensions(treeData) {
    var maxX = treeData.x;
    var minX = treeData.x;
    var maxY = treeData.y;
    var minY = treeData.y;

    var nodes = treeData.descendants();

    // Normalize for fixed-depth.
    nodes.forEach(function (d) {
      if (d.x > maxX) {
        maxX = d.x;
      }

      if (d.x < minX) {
        minX = d.x;
      }

      if (d.y > maxY) {
        maxY = d.y;
      }

      if (d.y < minY) {
        minY = d.y;
      }
    });

    var svgHeight = maxY - minY;
    var svgWidth = maxX - minX;

    svgWidth += 50; // padding
    svgHeight += 400; // padding

    g.transition()
        .duration(duration)
        .attr('transform', 'translate(' + 20 + ',' + (Math.abs(minX) + 25) + ')');


    var currentWidth = svg.attr('height');
    var currentHeight = svg.attr('width');

    if (svgWidth < currentWidth) {
      window.setTimeout(function () {
        svg.attr('height', svgWidth);
      }, duration);
    } else {
      svg.attr('height', svgWidth);
    }

    if (svgHeight < currentHeight) {
      window.setTimeout(function () {
        svg.attr('width', svgHeight);
      }, duration);
    } else {
      svg.attr('width', svgHeight);
    }
  }

  function drawNodes(treeData, source) {

    var previousNodePositions = previousState.nodePositions;

    // ignore the root node
    var nodes = treeData.descendants().slice(1);

    // Update the nodes...
    var node = g.selectAll('g.node')
        .data(nodes, function (d) {
          return d.id;
        });

    // Enter any new modes at the parent's previous position.
    var nodeEnter = node.enter()
        .append('g')
        .attr('class', 'node')
        .attr("transform", function (d) {
          var previousPositions = previousNodePosition(d);

          return "translate(" + previousPositions.y + "," + previousPositions.x + ")";
        })
        .on('click', function (d) {
          store.dispatch(selectNode(d.id, d._children ? true : true));
        });

    // Add Circle for the nodes
    nodeEnter.append('circle')
        .attr('class', 'node')
        .attr('r', 0)
    ;

    // Add labels for the nodes
    nodeEnter.append('text')
        .attr("dy", ".35em")
        .attr("x", 13)
        .attr("y", 0)
        .attr("text-anchor", "start")
        .text(function (d) {
          var parts = d.id.split(':');
          return (parts.length === 1) ? parts[0] : parts[1];
        })
    ;

    // UPDATE
    var nodeUpdate = nodeEnter.merge(node);

    // Transition to the proper position for the node
    nodeUpdate.transition()
        .duration(duration)
        .attr("transform", function (d) {
          return "translate(" + d.y + "," + d.x + ")";
        });

    // Update the node attributes and style
    nodeUpdate.select('circle.node')
        .attr('r', nodeRadius)
        .style('stroke', function (d) {
          var nodeData = roadRunnerNodes[d.id];

          if (nodeData && nodeData.extraData && nodeData.extraData.externalOrigin) {
            return "#67757B";
          }

          if (!nodeData || nodeData.type === 'class') {
            return "#4FC9FF";
          }

          if (nodeData.type === 'interface') {
            return "#a4d765";
          }

          if (nodeData.type === 'trait') {
            return "#ffc545";
          }
        })
        .style("fill", function (d) {
          var nodeData = roadRunnerNodes[d.id];

          if (!d._children) {
            return "#fff";
          }

          if (!nodeData || nodeData.type === 'class') {
            return "#9be0ff";
          }

          if (nodeData.type === 'interface') {
            return "#E4F7CB";
          }

          if (nodeData.type === 'trait') {
            return "#ffde96";
          }

        })
        .attr('cursor', 'pointer')
        .style('stroke-width', function (d) {
          if (d.id === source.id) {
            return '5px';
          }

          return '3px';
        });
    ;

    nodeUpdate.select('text')
        .attr('class', function (d) {
          if (d.id === source.id) {
            return 'node--selected-text';
          }

          return '';
        });


    // Remove any exiting nodes
    var nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", function (d) {
          return "translate(" + source.y + "," + source.x + ")";
        })
        .remove();

    // On exit reduce the node circles size to 0
    nodeExit.select('circle')
        .attr('r', 1e-6);

    // On exit reduce the opacity of text labels
    nodeExit.select('text').style('fill-opacity', 1e-6);
  }

  function drawLinks(treeData, source) {
    var previousNodePositions = previousState.nodePositions;

    var links = treeData.descendants().slice(1);

    // Update the links...
    var link = g.selectAll('path.link')
        .data(links, function (d) {
          return d.id;
        });

    // Enter any new links at the parent's previous position.
    var linkEnter = link.enter().insert('path', 'g')
        .attr('class', 'link')
        .attr('d', function (d) {
          var o = previousNodePosition(d);
          return diagonal(o, o)
        });

    // UPDATE
    var linkUpdate = linkEnter.merge(link);

    // Transition back to the parent element position
    linkUpdate
        .filter(function (d) {
          // don't draw edges to the namespace root
          return d.depth > 1;
        })
        .transition()
        .duration(duration)
        .attr('d', function (d) {
          return diagonal(d, d.parent)
        });

    // Remove any exiting links
    var linkExit = link.exit().transition()
        .duration(duration)
        .attr('d', function (d) {
          var o = {
            x: source.x,
            y: source.y
          };
          return diagonal(o, o)
        })
        .remove();
  }

  function recomputeTree() {
    treeData = tree(root);
    // Update y-position for nicely normalized depth
    treeData.descendants().forEach(function (d) {
      d.y = (d.depth - 1) * nodeWidth;
    });

    updateSvgDimensions(treeData);

    return treeData;
  }

  function updateGraph(previousState, nextState) {
    var sourceNode = nodeIndex[nextState.selectedNode.nodeId];

    if (!sourceNode) {
      sourceNode = root;
    }

    drawNodes(treeData, sourceNode);
    drawLinks(treeData, sourceNode);
  }
  observeStoreChanges(updateGraph);

  function updateLegend(previousState, nextState) {
    var sourceNode = roadRunnerNodes[nextState.selectedNode.nodeId];

    document.querySelectorAll('.legend--selected-node').forEach(function (domNode) {
      domNode.innerHTML = '';
    });

    if (sourceNode) {
      document.querySelectorAll('.legend--selected-node').forEach(function (domNode) {
        domNode.appendChild(document.createTextNode(' ' + sourceNode.name));
      });
    }

    if (nextState.showImplements.showSource) {
      var checkbox = document.querySelector('input[name="toggleImplements"]');
      if (checkbox) {
        checkbox.checked = 'checked';
      }
    } else {
      var checkbox = document.querySelector('input[name="toggleImplements"]');
      if (checkbox) {
        checkbox.checked = false;
      }
    }
  }
  observeStoreChanges(updateLegend);

  function drawImplementsEdges(previousState, nextState) {
    var sourceNode = nodeIndex[nextState.selectedNode.nodeId];

    if (!sourceNode) {
      return;
    }

    var paths = [];

    if (
        nextState.showImplements.showSource
        || nextState.showImplements.showImplicit
        || nextState.showImplements.showTargets
    ) {

      paths = _.values(findImplementsEdges(sourceNode, nextState.showImplements.showSource, nextState.showImplements.showImplicit, nextState.showImplements.showTargets));
    }

    var selection = g.selectAll('path.implements')
          .data(_.values(paths), function (d) {
            return d.id;
          });


    selection.enter()
          .insert('path', 'g')
          .attr('class', function(d) {
            var classList = ['dependency', 'implements'];

            if (d.ancestor) {
              classList.push('dependency--ancestor');
            }

            if (d.target) {
              classList.push('dependency--target');
            }

            return classList.join(' ');
          })
          .attr('d', function (d) {
            var pos = previousNodePosition(d.actualSource);
            return diagonal(pos, pos);
          })
          .transition()
          .duration(duration)
          .attr('d', function (d) {

            if (d.actualSource.depth === d.actualTarget.depth) {
              return exaggeratedDiagonal(d.actualSource, d.actualTarget);
            }

            return diagonal(d.actualSource, d.actualTarget);
          });

      selection.exit()
          .transition()
          .duration(duration)
          .attr('d', function (d) {
            return diagonal(d.actualSource, d.actualSource)
          })
          .remove();
  }
  observeStoreChanges(drawImplementsEdges);
</script>

<div class="info-box">
  Selected node:<span class="legend--selected-node"></span>
  <form id="graph-controls" name="legend" action="#" method="GET">
    <fieldset>
      <legend>Implements</legend>
      <div>
        <label><input type="checkbox" name="toggleImplements" value="true"/> Show dependencies</label>
      </div>
      <div>
        <label><input type="checkbox" name="toggleImplementsImplicit" value="true"/> Show implicit dependencies</label>
      </div>
      <div>
        <label><input type="checkbox" name="toggleImplementsTarget" value="true"/> Show dependent nodes</label>
      </div>
    </fieldset>
  </form>
</div>

<script>
  // Set up event handlers

  var form = document.getElementById('graph-controls');
  form.addEventListener('change', function () {
    var formData = new FormData(form);

    var toggleImplementsValue = formData.get('toggleImplements') === 'true' ? true : false
    var toggleImplementsImplicit = formData.get('toggleImplementsImplicit') === 'true' ? true : false
    var toggleImplementsTarget = formData.get('toggleImplementsTarget') === 'true' ? true : false
    store.dispatch(toggleImplements(toggleImplementsValue, toggleImplementsImplicit, toggleImplementsTarget));
  });

  // Init
  d3.json('js/class-hierarchy.json', function(error, hierarchy) {
    d3.json('js/class-nodes.json', function(error, nodes) {
      d3.json('js/class-edges.json', function(error, edges) {
        store.dispatch(initTree(hierarchy, nodes, edges));
      });
    });
  });
</script>
</body>
</html>
