<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Class Dependencies</title>

  <style>

    * {
      padding: 0;
      margin: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
    }

    svg {
      position: absolute;
      top: 0;
    }

    .branch {
      stroke: #555;
      stroke-width: 1px;
      stroke-opacity: 0.4;
      fill: none;
    }

    text {
      font-family: 'Helvetica Neue', 'Helvetica', sans-serif;
      font-size: 8pt;
    }

    circle.leaf {
      stroke: black;
      stroke-width: 3px;
      fill: #FFFFFF;
    }

    .dashed {
      stroke-dasharray: 2, 2;
    }


    .node circle {
      fill: #fff;
      stroke: #4FC9FF;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

  </style>

</head>
<body>
  <?xml version="1.0" standalone="no"?>
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>

  <script src="js/underscore.js"></script>
  <script src="js/d3/d3.js"></script>
  <script src="js/d3-force/d3-force.js"></script>
  <script src="js/class-graph.js"></script>

  <script>

    var countClasses = _.reduce(roadRunnerDeps.nodes, function(memo, node) {
      if (node.type == 'class') {
        return memo + 1;
      }
      return memo;
    }, 0);

    var sourceFilesWithClasses = _.reduce(roadRunnerDeps.edges, function (memo, edge) {

      if (edge.type == 'sourcefile') {
        if ((roadRunnerDeps.nodes[edge.source].type == 'class')
            || (roadRunnerDeps.nodes[edge.source].type == 'interface')) {
          memo[edge.target] = 1;
        }
      }

      return memo;
    }, {});

    var classesImplementingInterfaces = _.reduce(roadRunnerDeps.edges, function(memo, edge) {
      if (edge.type == 'implements') {
        if ((roadRunnerDeps.nodes[edge.source].type == 'class')) {
          memo[edge.source] = 1;
        }
      }

      return memo;
    }, {});

    var namespaces = _.reduce(roadRunnerDeps.nodes, function(memo, node) {
      if (node.type == 'namespace') {
        memo[node.id] = 1;
      }

      return memo;
    }, {});


    var namespaceMembers = _.reduce(roadRunnerDeps.edges, function(memo, edge) {
      if (edge.type == 'namespace') {
        if (((roadRunnerDeps.nodes[edge.source].type == 'class')
            || (roadRunnerDeps.nodes[edge.source].type == 'interface'))
        && (roadRunnerDeps.nodes[edge.target].name != '\\')
        ){
          memo[edge.source] = 1;
        }
      }

      return memo;
    }, {});

    var countManagers = _.reduce(roadRunnerDeps.nodes, function(memo, node) {
      if (node.id.indexOf('Manager') >= 0) {
        return memo + 1;
      }

      return memo;
    }, 0);


    var classInheritanceEdges = _.reduce(roadRunnerDeps.edges, function (memo, edge) {

      if (!roadRunnerDeps.nodes[edge.target]) {
//        console.log(edge);
      }

      if ((edge.type === 'extends') && (roadRunnerDeps.nodes[edge.target].type === 'class') && (roadRunnerDeps.nodes[edge.source].type === 'class')) {
        memo.push(edge);
      }

      return memo;

    }, []);

    var targets = _.uniq(_.reduce(classInheritanceEdges, function(memo, edge) {
//      console.log(edge);

      memo.push(edge.target);
      return memo;
    }, []));

    var sources = _.uniq(_.reduce(classInheritanceEdges, function(memo, edge) {
      memo.push(edge.source);
      return memo;
    }, []));

    var leftovers = _.difference(targets, sources);

    var tmpRoot = '';
    if (leftovers.length > 1) {
      tmpRoot = '__root';
    }
    _.each(leftovers, function(leftover) {
      classInheritanceEdges.push({
        source: leftover,
        target: tmpRoot,
        type: 'extends'
      });
    });

    if (tmpRoot !== '') {
      classInheritanceEdges.push({
        source: tmpRoot,
        target: '',
        type: 'extends'
      });
    }

    var root = d3.stratify().id(function(d) { return d.source; }).parentId(function(d) { return d.target; })(classInheritanceEdges);
    root.sort(function(a, b) {
      var nodeA = roadRunnerDeps.nodes[a.id];
      var nodeB = roadRunnerDeps.nodes[b.id];

      return nodeA.name.localeCompare(nodeB.name);
    });

    function collapse(tData) {

      if (tData.children) {
        tData._children = tData.children;
        tData._children.forEach(collapse);
        tData.children = null;
      }
    }

    function expand(tData) {
      if (tData._children) {
        tData.children = tData._children;
        tData._children = null;
      }
    }

    function click(tData) {
      if (tData._children) {
        expand(tData);
      } else if (tData.children) {
        collapse(tData);
      }

      update(tData);
    }

    root.children.forEach(collapse);


    var svg = d3.select('svg');
//    var width = window.innerWidth;
    var height = window.innerHeight;

    var width = 20000;
    var height = 40000;
    svg.attr('width', width);
    svg.attr('height', height);
    var g = svg.append('g');//.attr('transform', 'translate(20, 20)');

    //      var cluster = d3.cluster().size([height, width]);
//    var tree = d3.tree();
    var tree = d3.cluster();
    tree.separation(function(a, b) {
      return a.parent == b.parent ? 0.25 : 0.5;
    });
//    tree.size([height, width]);
    tree.nodeSize([100, 100]);


    var i = 0,
        duration = 750;

    var nodeHeight = 30;
    var nodeWidth = 380;

    root.x0 = 90;
    root.y0 = height / 2;

    // Creates a curved (diagonal) path from parent to the child nodes
    function diagonal(s, d) {

      var path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`;

      return path;
    }

    function update(source) {
      
      // Assigns the x and y position for the nodes
      var treeData = tree(root);

      // Compute the new tree layout.
      var nodes = treeData.descendants(),
          links = treeData.descendants().slice(1);


      var totalHeight = nodes.length * nodeHeight;

      var maxX = root.x;
      var minX = root.x;
      var maxY = root.y;
      var minY = root.y;


      // Normalize for fixed-depth.
      nodes.forEach(function(d){
        d.y = (d.depth) * nodeWidth;

        if (d.x > maxX) {
          maxX = d.x;
        }

        if (d.x < minX) {
          minX = d.x;
        }

        if (d.y > maxY) {
          maxY = d.y;
        }

        if (d.y < minY) {
          minY = d.y;
        }
      });

      root.x = minX;

      var svgHeight = maxY - minY;
      var svgWidth = maxX - minX;

      svgWidth += 50; // padding
      svgHeight += 400; // padding

      g.transition()
          .duration(duration)
          .attr('transform', 'translate(' + 20 + ',' + (Math.abs(minX) + 25) + ')');


      var currentWidth = svg.attr('height');
      var currentHeight = svg.attr('width');

      if (svgWidth < currentWidth) {
        window.setTimeout(function () {
          svg.attr('height', svgWidth);
        }, duration);
      } else {
        svg.attr('height', svgWidth);
      }

      if (svgHeight < currentHeight) {
        window.setTimeout(function () {
          svg.attr('width', svgHeight);
        }, duration);
      } else {
        svg.attr('width', svgHeight);
      }


      // ****************** Nodes section ***************************

      // Update the nodes...
      var node = g.selectAll('g.node')
          .data(nodes, function(d) {
            return d.id;
          });

      // Enter any new modes at the parent's previous position.
      var nodeEnter = node.enter()
          .append('g')
          .attr('class', 'node')
          .attr("transform", function(d) {
            return "translate(" + source.y0 + "," + source.x0 + ")";
          })
          .on('click', click);

      // Add Circle for the nodes
      nodeEnter.append('circle')
          .attr('class', 'node')
          .attr('r', 1e-6)
          .style("fill", function(d) {
            return d._children ? "lightsteelblue" : "#fff";
          });

      // Add labels for the nodes
      nodeEnter.append('text')
          .attr("dy", ".35em")
          .attr("x", 13)
          .attr("y", 0)
          .attr("text-anchor", "start")
          .text(function(d) {
            var parts = d.id.split(':');
            return (parts.length === 1)? parts[0] : parts[1];
          });

      // UPDATE
      var nodeUpdate = nodeEnter.merge(node);

      // Transition to the proper position for the node
      nodeUpdate.transition()
          .duration(duration)
          .attr("transform", function(d) {
            return "translate(" + d.y + "," + d.x + ")";
          });

      // Update the node attributes and style
      nodeUpdate.select('circle.node')
          .attr('r', 10)
          .style("fill", function(d) {
            return d._children ? "#9be0ff" : "#fff";
          })
          .attr('cursor', 'pointer');


      // Remove any exiting nodes
      var nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", function(d) {
            return "translate(" + source.y + "," + source.x + ")";
          })
          .remove();

      // On exit reduce the node circles size to 0
      nodeExit.select('circle')
          .attr('r', 1e-6);

      // On exit reduce the opacity of text labels
      nodeExit.select('text')
          .style('fill-opacity', 1e-6);

      // ****************** links section ***************************

      // Update the links...
      var link = g.selectAll('path.link')
          .data(links, function(d) {
            return d.id;
          });

      // Enter any new links at the parent's previous position.
      var linkEnter = link.enter().insert('path', "g")
          .attr("class", "link")
          .attr('d', function(d){
            var o = {
              x: source.x0,
              y: source.y0}
            return diagonal(o, o)
          });

      // UPDATE
      var linkUpdate = linkEnter.merge(link);

      // Transition back to the parent element position
      linkUpdate.transition()
          .duration(duration)
          .attr('d', function(d){ return diagonal(d, d.parent) });

      // Remove any exiting links
      var linkExit = link.exit().transition()
          .duration(duration)
          .attr('d', function(d) {
            var o = {x: source.x, y: source.y};
            return diagonal(o, o)
          })
          .remove();

      // Store the old positions for transition.
      nodes.forEach(function(d){
        d.x0 = d.x;
        d.y0 = d.y;
      });

    }



    update(root);
  </script>

</body>
</html>